{
    "contents" : "---\nlayout: lesson\nroot: ../..\n---\n\n```{r, include = FALSE}\nsource(\"chunk_options.R\")\nopts_chunk$set(fig.path = \"figure/01-starting-with-data-\")\n```\n\n## Analyzing Patient Data\n\nWe are studying inflammation in patients who have been given a new treatment for arthritis,\nand need to analyze the first dozen data sets. \nThe data sets are stored in [comma-separated values](../../gloss.html#comma-separeted-values) (CSV) format: each row holds information for a single patient, and the columns represent successive days. \nThe first few rows of our first file look like this:\n\n```{r echo = FALSE}\ntmp <- read.csv(\"inflammation-01.csv\", header = FALSE, nrows = 5)\nwrite.table(tmp, quote = FALSE, sep = \",\", row.names = FALSE, col.names = FALSE)\nrm(tmp)\n```\n\nWe want to:\n\n* load that data into memory,\n* calculate the average inflammation per day across all patients, and\n* plot the result.\n\nTo do all that, we'll have to learn a little bit about programming.\n\n#### Objectives\n\n* Read tabular data from a file into a program.\n* Assign values to variables.\n* Select individual values and subsections from data.\n* Perform operations on a data frame of data.\n* Display simple graphs.\n\n### Loading Data\n\nTo load our inflammation data, first we need to locate our data.\nWe can change the current working directory to the location of the CSV files using the function `setwd`.\nFor example, if the CSV files are located in a directory named `swc` in our home directory, we would change the working directory using the following command:\n\n```{r, eval=FALSE}\nsetwd(\"~/swc\")\n```\n\nJust like in the Unix Shell, we type the command and then press `Enter` (or `return`).\nAlternatively you can change the working directory using the RStudio GUI using the menu option `Session` -> `Set Working Directory` -> `Choose Directory...`\n\nNow we could load the data into R using `read.csv`:\n\n```{r, results=\"hide\"}\nread.csv(file = \"inflammation-01.csv\", header = FALSE)\n```\n\nThe expression `read.csv(...)` is a [function call](../../gloss.html#function-call) that asks R to run the function `read.csv`. \n\n`read.csv` has two [arguments](../../gloss.html#argument): the name of the file we want to read, and whether the first line of the file contains names for the columns of data.\nThe filename needs to be a character string (or [string](../../gloss.html#string) for short), so we put it in quotes.\nAssigning the second argument, `header`, to be `FALSE` indicates that the data file does not have column headers.\nWe'll talk more about the value `FALSE`, and its converse `TRUE`, in lesson 04.\n\nThe utility of a function is that it will perform its given action on whatever value is passed to the named argument(s).\nFor example, in this case if we provided the name of a different file to the argument `file`, `read.csv` would read it instead.\nWe'll learn more of the details about functions and their arguments in the next lesson.\n\nSince we didn't tell it to do anything else with the function's output, the console will display the full contents of the file `inflammation-01.csv`.\nTry it out.\n\n`read.csv` read the file, but didn't save the data in memory.\nTo do that, we need to assign the data frame to a variable.\nA variable is just a name for a value, such as `x`, `current_temperature`, or `subject_id`.\nWe can create a new variable simply by assigning a value to it using `<-`\n\n```{r}\nweight_kg <- 55\n```\n\nOnce a variable has a value, we can print it by typing the name of the variable and hitting `Enter` (or `return`).\nIn general, R will print to the console any object returned by a function or operation *unless* we assign it to a variable.\n\n```{r}\nweight_kg\n```\n\nWe can do arithmetic with the variable:\n\n```{r}\n# weight in pounds:\n2.2 * weight_kg\n```\n\n> **Tip:** We can add comments to our code using the `#` character.\nIt is useful to document our code in this way so that others (and us the next time we read it) have an easier time following what the code is doing.\n\nWe can also change an object's value by assigning it a new value:\n\n```{r}\nweight_kg <- 57.5\n# weight in kilograms is now\nweight_kg\n```\n\nIf we imagine the variable as a sticky note with a name written on it, \nassignment is like putting the sticky note on a particular value:\n\n<img src=\"../python/img/python-sticky-note-variables-01.svg\" alt=\"Variables as Sticky Notes\" />\n\nThis means that assigning a value to one object does not change the values of other variables. \nFor example, let's store the subject's weight in pounds in a variable:\n\n```{r}\nweight_lb <- 2.2 * weight_kg\n# weight in kg...\nweight_kg\n# ...and in pounds\nweight_lb\n```\n\n<img src=\"../python/img/python-sticky-note-variables-02.svg\" alt=\"Creating Another Variable\" />\n\nand then change `weight_kg`:\n\n```{r}\nweight_kg <- 100.0\n# weight in kg now...\nweight_kg\n# ...and in weight pounds still\nweight_lb\n```\n\n<img src=\"../python/img/python-sticky-note-variables-03.svg\" alt=\"Updating a Variable\" />\n\nSince `weight_lb` doesn't \"remember\" where its value came from, it isn't automatically updated when `weight_kg` changes. \nThis is different from the way spreadsheets work.\n\nNow that we know how to assign things to variables, let's re-run `read.csv` and save its result:\n\n```{r}\ndat <- read.csv(file = \"inflammation-01.csv\", header = FALSE)\n```\n\nThis statement doesn't produce any output because assignment doesn't display anything.\nIf we want to check that our data has been loaded, we can print the variable's value.\nHowever, for large data sets it is convenient to use the function `head` to display only the first few rows of data.\n\n```{r}\nhead(dat)\n```\n\n#### Challenge\n\nDraw diagrams showing what variables refer to what values after each statement in the following program:\n\n\tmass <- 47.5\n\tage <- 122\n\tmass <- mass * 2.0\n\tage <- age - 20\n\n### Manipulating Data\n\nNow that our data is in memory, we can start doing things with it. \nFirst, let's ask what type of thing `dat` *is*:\n\n```{r}\nclass(dat)\n```\n\nThe output tells us that data currently is a data frame in R. \nThis is similar to a spreadsheet in MS Excel that many of us are familiar with using.\nData frames are very useful for storing data because you can have a continuous variable, e.g. rainfall, in one column and a categorical variable, e.g. month, in another.\n\nWe can see the dimensions, or [shape](../../gloss.html#shape), of the data frame like this:\n\n```{r}\ndim(dat)\n```\n\nThis tells us that our data frame, `dat`, has `r nrow(dat)` rows and `r ncol(dat)` columns.\n\nIf we want to get a single value from the data frame, we can provide an [index](../../gloss.html#index) in square brackets, just as we do in math:\n\n```{r}\n# first value in dat\ndat[1, 1]\n# middle value in dat\ndat[30, 20]\n```\n\nAn index like `[30, 20]` selects a single element of a data frame, but we can select whole sections as well. \nFor example, we can select the first ten days (columns) of values for the first four patients (rows) like this:\n\n```{r}\ndat[1:4, 1:10]\n```\n\nThe [slice](../../gloss.html#slice) `1:4` means, \"Start at index 1 and go to index 4.\"\n\nThe slice does not need to start at 1, e.g. the line below selects rows 5 through 10:\n\n```{r}\ndat[5:10, 1:10]\n```\n\nWe can use the function `c`, which stands for **c**ombine, to select non-contiguous values:\n\n```{r}\ndat[c(3, 8, 37, 56), c(10, 14, 29)]\n```\n\nWe also don't have to provide a slice for either the rows or the columns.\nIf we don't include a slice for the rows, R returns all the rows; if we don't include a slice for the columns, R returns all the columns.\nIf we don't provide a slice for either rows or columns, e.g. `dat[, ]`, R returns the full data frame.\n\n```{r}\n# All columns from row 5\ndat[5, ]\n# All rows from column 16\ndat[, 16]\n```\n\nNow let's perform some common mathematical operations to learn about our inflammation data.\nWhen analyzing data we often want to look at partial statistics, such as the maximum value per patient or the average value per day. \nOne way to do this is to select the data we want to create a new temporary data frame, and then perform the calculation on this subset:\n\n```{r}\n# first row, all of the columns\npatient_1 <- dat[1, ]\n# max inflammation for patient 1\nmax(patient_1)\n```\n\nWe don't actually need to store the row in a variable of its own. \nInstead, we can combine the selection and the function call:\n\n```{r}\n# max inflammation for patient 2\nmax(dat[2, ])\n```\n\nR also has functions for other commons calculations, e.g. finding the minimum, mean, median, and standard deviation of the data:\n\n```{r}\n# minimum inflammation on day 7\nmin(dat[, 7])\n# mean inflammation on day 7\nmean(dat[, 7])\n# median inflammation on day 7\nmedian(dat[, 7])\n# standard deviation of inflammation on day 7\nsd(dat[, 7])\n```\n\nWhat if we need the maximum inflammation for all patients, or the average for each day?\nAs the diagram below shows, we want to perform the operation across a margin of the data frame:\n\n<img src=\"figure/r-operations-across-axes.svg\" alt=\"Operations Across Axes\" />\n\nTo support this, we can use the `apply` function.\n\n> **Tip:** To learn about a function in R, e.g. `apply`, we can read its help documention by running `help(apply)` or `?apply`.\n\n`apply` allows us to repeat a function on all of the rows (`MARGIN = 1`) or columns (`MARGIN = 2`) of a data frame.\n\nThus, to obtain the average inflammation of each patient we will need to calculate the mean of all of the rows (`MARGIN = 1`) of the data frame.\n\n```{r}\navg_patient_inflammation <- apply(dat, 1, mean)\n```\n\nAnd to obtain the average inflammation of each day we will need to calculate the mean of all of the columns (`MARGIN = 2`) of the data frame.\n\n```{r}\navg_day_inflammation <- apply(dat, 2, mean)\n```\n\nSince the second argument to `apply` is `MARGIN`, the above command is equivalent to `apply(dat, MARGIN = 2, mean)`.\nWe'll learn why this is so in the next lesson.\n\n> **Tip:** Some common operations have more efficient alternatives.\nFor example, you can calculate the row-wise or column-wise means with `rowMeans` and `colMeans`, respectively.\n\n#### Challenge\n\nA subsection of a data frame is called a [slice](../../gloss.html#slice).\nWe can take slices of character vectors as well:\n\n```{r}\nelement <- c(\"o\", \"x\", \"y\", \"g\", \"e\", \"n\")\n# first three characters\nelement[1:3]\n# last three characters\nelement[4:6]\n```\n\n1.  If the first four characters are selected using the slice `element[1:4]`, how can we obtain the first four characters in reverse order?\n    \n1.  What is `element[-1]`?\n    What is `element[-4]`?\n    Given those answers,\n    explain what `element[-1:-4]` does.\n\n1.  Use a slice of `element` to create a new character vector that spells the word \"eon\", e.g. `c(\"e\", \"o\", \"n\")`.\n\n### Plotting\n\nThe mathematician Richard Hamming once said, \"The purpose of computing is insight, not numbers,\" and the best way to develop insight is often to visualize data.\nVisualization deserves an entire lecture (or course) of its own, but we can explore a few of R's plotting features. \n\nLet's take a look at the average inflammation over time.\nRecall that we already calculated these values above using `apply(dat, 2, mean)` and saved them in the variable `avg_day_inflammation`.\nPlotting the values is done with the function `plot`.\n\n```{r plot-avg-inflammation}\nplot(avg_day_inflammation)\n```\n\nAbove, we gave the function `plot` a vector of numbers corresponding to the average inflammation per day across all patients.\n`plot` created a scatter plot where the y-axis is the average inflammation level and the x-axis is the order, or index, of the values in the vector, which in this case correspond to the 40 days of treatment.\nThe result is roughly a linear rise and fall, which is suspicious: based on other studies, we expect a sharper rise and slower fall.\nLet's have a look at two other statistics: the maximum and minimum inflammation per day.\n\n```{r plot-max-inflammation}\nmax_day_inflammation <- apply(dat, 2, max)\nplot(max_day_inflammation)\n```\n\n```{r plot-min-inflammation}\nmin_day_inflammation <- apply(dat, 2, min)\nplot(min_day_inflammation)\n```\n\nThe maximum value rises and falls perfectly smoothly, while the minimum seems to be a step function. Neither result seems particularly likely, so either there's a mistake in our calculations or something is wrong with our data.\n\n#### Challenge\n\nCreate a plot showing the standard deviation of the inflammation data \nfor each day across all patients.\n\n#### Key Points\n\n* Use `variable <- value` to assign a value to a variable in order to record it in memory.\n* Objects are created on demand whenever a value is assigned to them.\n* The function `dim` gives the dimensions of a data frame.\n* Use `object[x, y]` to select a single element from a data frame.\n* Use `from:to` to specify a sequence that includes the indices from `from` to `to`.\n* All the indexing and slicing that works on data frames also works on vectors.\n* Use `#` to add comments to programs.\n* Use `mean`, `max`, `min` and `sd` to calculate simple statistics.\n* Use `apply` to calculate statistics across the rows or columns of a data frame.\n* Use `plot` to create simple visualizations.\n\n#### Next Steps\n\nOur work so far has convinced us that something's wrong with our first data file.\nWe would like to check the other 11 the same way, but typing in the same commands repeatedly is tedious and error-prone.\nSince computers don't get bored (that we know of), we should create a way to do a complete analysis with a single command, and then figure out how to repeat that step once for each file.\nThese operations are the subjects of the next two lessons.\n",
    "created" : 1411749517082.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "873517161",
    "id" : "109006EA",
    "lastKnownWriteTime" : 1411751283,
    "path" : "/data/projects/DataInformatics/swcarpentry/bc/novice/r/01-starting-with-data.Rmd",
    "project_path" : "novice/r/01-starting-with-data.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}