<div id="s:invperc:opening" class="opening">

  <p>
    Ethan Ecosystem is studying the way pollutants spreads through fractured rock
    (<a href="#f:invasion_percolation">Figure 1</a>).
    To simulate this,
    he wants to use a model called
    <a href="glossary.html#invasion-percolation">invasion percolation</a>.
  </p>

  <figure id="f:invasion_percolation">
    <img src="dev/invasion_percolation.png" alt="Invasion Percolation" />
    <figcaption>Figure 1: Invasion Percolation</figcaption>
  </figure>

  <p>
    In its simplest form,
    invasion percolation represents the rock that the pollutant is spreading through
    as a two-dimensional grid of square cells filled with random values.
    The algorithm starts by marking the center cell as being polluted,
    then looks at that cell's four neighbors
    (<a href="#f:invasion_percolation_algorithm">Figure 2</a>).
    The one with the lowest value is the one that has the least resistance to the spread of the pollutant,
    so the algorithm marks that as being filled as well.
    It then looks at the six neighbors of the entire filled region,
    and once again finds and marks the one with the lowest value.
    This process continues until a certain percentage of cells have been filled
    (i.e., there's no more pollutant),
    or until the pollution reaches the boundary of the grid.
  </p>

  <figure id="f:invasion_percolation_algorithm">
    <img src="dev/invasion_percolation_algorithm.png" alt="Invasion Percolation Algorithm" />
    <figcaption>Figure 2: Invasion Percolation Algorithm</figcaption>
  </figure>

  <p>
    If two or more cells on the boundary are tied equal for the lowest value,
    the algorithm can either fill them all in simultaneously,
    or pick one at random and fill that in.
    Either way,
    the fractal this algorithm produces will tell Ethan how quickly the pollutant will spread,
    and how much of the rock will be contaminated.
  </p>

  <p>
    But if Ethan wants to look at the statistical properties of these fractals,
    he will need to do many simulation on large grids.
    That means his program has to be fast,
    so this lesson will look at:
  </p>

  <ol>

    <li>
      how we build a program like this in the first place,
    </li>

    <li>
      how we tell if it's working correctly,
      and
    </li>

    <li>
      how we speed it up.
    </li>

  </ol>

  <p>
    The order of the second and third steps is important.
    There's no point speeding something up if it isn't working correctly,
    or if we don't know whether it's working correctly or not.
    Once we know how to tell,
    on the other hand,
    we can focus on performance improvement,
    secure in the knowledge that if one of our bright ideas breaks things,
    our program will let us know.
  </p>

</div>
