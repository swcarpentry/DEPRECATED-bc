<div id="s:invperc:instructors" class="instructors">

  <p>
    I have never gotten as far as this lesson
    in a two-day boot camp aimed at novices,
    but I have frequently used it in week-long classes,
    or in classes aimed at more experienced learners.
    It has everything we want in an extended example:
    the problem being solved is easy to understand,
    many of the ideas we've discussed in earlier lessons
    come up naturally during implementation,
    testing is challenging but possible,
    and it motivates two new ideas
    (performance profiling and algorithmic improvement).
    It's also a great lead-in to a discussion of object-oriented programming:
    once the grid has been refactored a couple of times,
    it's natural to rewrite it as a class,
    and then swap in another version that has the same interface
    but uses NumPy for storage.
  </p>

  <p>
    How this lesson is presented is just as important as its content.
    We teach top-down refinement,
    but most programmers actually start by working out a few key details,
    then growing toward those fixed points.
    For example,
    a programmer might build a clustering program by
    implementing the core algorithm and the data structures it uses,
    then growing outward to include I/O routines,
    some post-analysis,
    a user interface,
    and so on.
    This lesson uses that development cycle,
    which is why the main routine of the program doesn't appear until
    <a href="#s:assembly">the middle</a>.
  </p>

</div>
