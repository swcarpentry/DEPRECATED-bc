<div id="s:invperc:summary" class="summary">

  <p>  
    The key idea of this chapter is that
    good software comes from iteration with feedback.
    The way to create a complex program that is fast and correct is
    to make something simple and slow,
    get tests in place to make sure that it keeps producing the right answer
    as changes are made,
    and then to add features and make performance improvements one at a time.
    Choosing the right algorithms and data structures can yield enormous speedups,
    so we should always look there first for performance gains.
    This is where a broad knowledge of computer science comes in handy:
    any good book on data structures and algorithms describes dozens or hundreds of things
    that are exactly what's needed to solve some obscure but vital performance problem.
  </p>

  <p>  
    And improving the quality of our code improves both our performance and the machine's:
    it is the opposite of an either/or tradeoff.
    Well-structured programs are easier to optimize than poorly-structured ones,
    so if we build our program as a collection of functions more-or-less independent functions,
    we can improve those functions more or less independently.
  </p>

  <p>
    The same ideas apply at a larger scale.
    If we want the next project to take less time (and hurt less) than this one,
    we need to improve our development process
    rather than putting more hours into doing things the wrong way.
    In the long run,
    what distinguishes successful teams and projects from unsuccessful ones isn't any specific set of practices,
    but humility.
  </p>

</div>
